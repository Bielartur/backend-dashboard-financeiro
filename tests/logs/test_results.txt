============================= test session starts =============================
platform win32 -- Python 3.13.2, pytest-9.0.2, pluggy-1.6.0 -- C:\Users\gabri\OneDrive\Documentos\Vibe Coding\backend-financas\.venv\Scripts\python.exe
cachedir: .pytest_cache
rootdir: C:\Users\gabri\OneDrive\Documentos\Vibe Coding\backend-financas
configfile: pyproject.toml
plugins: anyio-4.12.0, asyncio-1.3.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 13 items

tests/payments/test_controller.py::test_create_payment_api FAILED        [  7%]
tests/payments/test_controller.py::test_search_payments_api PASSED       [ 15%]
tests/payments/test_controller.py::test_get_payment_by_id_api PASSED     [ 23%]
tests/payments/test_controller.py::test_update_payment_api PASSED        [ 30%]
tests/payments/test_controller.py::test_delete_payment_api PASSED        [ 38%]
tests/payments/test_parsers.py::test_parse_invoice_valid_csv FAILED      [ 46%]
tests/payments/test_parsers.py::test_parse_statement_valid_csv FAILED    [ 53%]
tests/payments/test_service.py::test_create_payment FAILED               [ 61%]
tests/payments/test_service.py::test_get_payment_by_id FAILED            [ 69%]
tests/payments/test_service.py::test_get_payment_not_found FAILED        [ 76%]
tests/payments/test_service.py::test_pdate_payment FAILED                [ 84%]
tests/payments/test_service.py::test_delete_payment FAILED               [ 92%]
tests/payments/test_service.py::test_search_payments FAILED              [100%]

================================== FAILURES ===================================
___________________________ test_create_payment_api ___________________________

client = <starlette.testclient.TestClient object at 0x000002A3E57C6E40>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0QGV4YW1wbGUuY29tIiwiaWQiOiI5ZGFlMjE1Yi1lNGE3LTQzNTctYjY5YS04MDBkNTFhMTYwNTUiLCJleHAiOjE3Njg1OTE0Njl9.8Z2TodM30JaI9et9MWe4g9i23QIIgx1XugIUnjLB0P8'}
sample_category = <Category(name='API Test Category', type='CategoryType.EXPENSE', color_hex='#123456')>

    def test_create_payment_api(client, auth_headers, sample_category):
        payload = {
            "title": "API Payment",
            "date": "2023-10-10",
            "amount": -50.50,
            "paymentMethod": "credit_card",
            "categoryId": str(sample_category.id),
            "bankId": str(uuid4()),  # Mock bank ID
        }
    
        response = client.post("/payments/", json=payload, headers=auth_headers)
        assert response.status_code == 201
        data = response.json()
        assert data["title"] == "API Payment"
>       assert data["amount"] == -50.50
E       AssertionError: assert '-50.5000000000' == -50.5

tests\payments\test_controller.py:36: AssertionError
---------------------------- Captured stderr call -----------------------------
INFO:root:Novo merchant e alias criados automaticamente: API Payment
INFO:root:Novo pagamento registrado para o usußrio de ID: 9dae215b-e4a7-4357-b69a-800d51a16055
INFO:httpx:HTTP Request: POST http://testserver/payments/ "HTTP/1.1 201 Created"
------------------------------ Captured log call ------------------------------
INFO     root:service.py:217 Novo merchant e alias criados automaticamente: API Payment
INFO     root:service.py:283 Novo pagamento registrado para o usußrio de ID: 9dae215b-e4a7-4357-b69a-800d51a16055
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/payments/ "HTTP/1.1 201 Created"
________________________ test_parse_invoice_valid_csv _________________________

nubank_parser = <src.payments.parsers.nubank.NubankParser object at 0x000002A3E57E7380>

    @pytest.mark.asyncio
    async def test_parse_invoice_valid_csv(nubank_parser):
        # Mock content: date,category,title,amount
        csv_content = """date,category,title,amount
    2023-10-01,food,Lunch,25.50
    2023-10-02,transport,Uber,15.00
    2023-10-03,payment,Pagamento recebido,-100.00
    """
        mock_file = MagicMock(spec=UploadFile)
        mock_file.read = AsyncMock(return_value=csv_content.encode("utf-8"))
    
        results = await nubank_parser.parse_invoice(mock_file)
    
        assert len(results) == 3
    
        # Check Expense (Positive in CSV -> Negative Amount)
        assert results[0].date == date(2023, 10, 1)
        assert results[0].title == "Lunch"
        assert results[0].amount == Decimal("-25.50")
>       assert results[0].payment_method == PaymentMethod.CreditCard
E       AssertionError: assert PaymentMethodSchema(value='credit_card', display_name='Cart\xe3o de Cr\xe9dito') == <PaymentMethod.CreditCard: 'credit_card'>
E        +  where PaymentMethodSchema(value='credit_card', display_name='Cart\xe3o de Cr\xe9dito') = PaymentImportResponse(id=None, date=datetime.date(2023, 10, 1), title='Lunch', amount=Decimal('-25.50'), category=None, has_merchant=True, already_exists=False, payment_method=PaymentMethodSchema(value='credit_card', display_name='Cart\xe3o de Cr\xe9dito')).payment_method
E        +  and   <PaymentMethod.CreditCard: 'credit_card'> = PaymentMethod.CreditCard

tests\payments\test_parsers.py:34: AssertionError
_______________________ test_parse_statement_valid_csv ________________________

nubank_parser = <src.payments.parsers.nubank.NubankParser object at 0x000002A3E5962710>

    @pytest.mark.asyncio
    async def test_parse_statement_valid_csv(nubank_parser):
        # Mock content: Data,Valor,Identificador,DescriþÒo
        csv_content = """Data,Valor,Identificador,DescriþÒo
    01/10/2023,-50.00,uuid-1234,TransferÛncia enviada pelo Pix - JoÒo Silva
    02/10/2023,-20.00,uuid-5678,Compra no dÚbito - Padaria
    03/10/2023,-100.00,uuid-9012,Pagamento de fatura
    04/10/2023,1000.00,uuid-3456,TransferÛncia recebida pelo Pix - Salary
    """
        mock_file = MagicMock(spec=UploadFile)
        mock_file.read = AsyncMock(return_value=csv_content.encode("utf-8"))
    
        results = await nubank_parser.parse_statement(mock_file)
    
        assert len(results) == 4
    
        # Pix Sent
>       assert results[0].payment_method == PaymentMethod.Pix
E       AssertionError: assert PaymentMethodSchema(value='pix', display_name='Pix') == <PaymentMethod.Pix: 'pix'>
E        +  where PaymentMethodSchema(value='pix', display_name='Pix') = PaymentImportResponse(id=None, date=datetime.date(2023, 10, 1), title='Jo\xe3o Silva', amount=Decimal('-50.00'), category=None, has_merchant=True, already_exists=False, payment_method=PaymentMethodSchema(value='pix', display_name='Pix')).payment_method
E        +  and   <PaymentMethod.Pix: 'pix'> = PaymentMethod.Pix

tests\payments\test_parsers.py:60: AssertionError
_____________________________ test_create_payment _____________________________

current_user = <User(username='test@example.com', first_name='Test', last_name='User')>
db = <sqlalchemy.orm.session.Session object at 0x000002A3E5967AD0>
payment = PaymentCreate(title='Test Payment', date=datetime.date(2023, 10, 1), amount=Decimal('-50.00'), payment_method=<Payment...rd: 'credit_card'>, bank_id=None, id=None, category_id=UUID('82678dad-46ee-4ca3-b84a-17cf9af3a1e1'), has_merchant=True)

    def create_payment(
        current_user: TokenData, db: Session, payment: model.PaymentCreate
    ) -> Payment:
        try:
>           processed_data = _process_payment_merchant_and_category(
                current_user, db, payment
            )

src\payments\service.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

current_user = <User(username='test@example.com', first_name='Test', last_name='User')>
db = <sqlalchemy.orm.session.Session object at 0x000002A3E5967AD0>
payment_data = PaymentCreate(title='Test Payment', date=datetime.date(2023, 10, 1), amount=Decimal('-50.00'), payment_method=<Payment...rd: 'credit_card'>, bank_id=None, id=None, category_id=UUID('82678dad-46ee-4ca3-b84a-17cf9af3a1e1'), has_merchant=True)

    def _process_payment_merchant_and_category(
        current_user: TokenData, db: Session, payment_data: model.PaymentCreate
    ) -> dict:
        # Buscar ou criar merchant baseado no title exato e usußrio
        merchant = (
            db.query(Merchant)
            .filter(Merchant.name == payment_data.title)
>           .filter(Merchant.user_id == current_user.get_uuid())
                                        ^^^^^^^^^^^^^^^^^^^^^
            .first()
        )
E       AttributeError: 'User' object has no attribute 'get_uuid'

src\payments\service.py:196: AttributeError

During handling of the above exception, another exception occurred:

db_session = <sqlalchemy.orm.session.Session object at 0x000002A3E5967AD0>
test_user = <User(username='test@example.com', first_name='Test', last_name='User')>
sample_category = <Category(name='Test Category', type='CategoryType.EXPENSE', color_hex='#000000')>

    def test_create_payment(db_session, test_user, sample_category):
        payment_data = PaymentCreate(
            title="Test Payment",
            date=date(2023, 10, 1),
            amount=Decimal("-50.00"),
            payment_method=PaymentMethod.CreditCard,
            bank_id=uuid4(),  # Mock, assuming no FK constraint on Bank for simplicity or need Bank fixture?
            # Wait, Bank IS a FK. We need a Bank fixture if we want to be strict.
            # But 'bank_id' in Payment entity is nullable? Let's check.
            # In src/entities/payment.py: bank_id = Column(UUID(as_uuid=True), ForeignKey("banks.id"), nullable=True)
            # So it can be None or valid. If we pass uuid4() that doesn't exist, it might fail FK check.
            # Let's set it to None for this basic test or create a Bank.
            category_id=sample_category.id,
        )
        # Removing bank_id for now to avoid FK error without Bank fixture
        payment_data.bank_id = None
    
>       payment = service.create_payment(test_user, db_session, payment_data)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\payments\test_service.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

current_user = <User(username='test@example.com', first_name='Test', last_name='User')>
db = <sqlalchemy.orm.session.Session object at 0x000002A3E5967AD0>
payment = PaymentCreate(title='Test Payment', date=datetime.date(2023, 10, 1), amount=Decimal('-50.00'), payment_method=<Payment...rd: 'credit_card'>, bank_id=None, id=None, category_id=UUID('82678dad-46ee-4ca3-b84a-17cf9af3a1e1'), has_merchant=True)

    def create_payment(
        current_user: TokenData, db: Session, payment: model.PaymentCreate
    ) -> Payment:
        try:
            processed_data = _process_payment_merchant_and_category(
                current_user, db, payment
            )
            new_payment = Payment(**processed_data)
    
            db.add(new_payment)
            db.commit()
            db.refresh(new_payment)
            logging.info(
                f"Novo pagamento registrado para o usußrio de ID: {current_user.get_uuid()}"
            )
            return new_payment
        except PaymentCreationError:
            db.rollback()
            raise
        except Exception as e:
            db.rollback()
            logging.error(
>               f"Falha na criaþÒo de pagamento para o usußrio de ID: {current_user.get_uuid()}: {str(e)}"
                                                                       ^^^^^^^^^^^^^^^^^^^^^
            )
E           AttributeError: 'User' object has no attribute 'get_uuid'

src\payments\service.py:293: AttributeError
___________________________ test_get_payment_by_id ____________________________

self = <sqlalchemy.engine.base.Connection object at 0x000002A3E5993350>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5991FD0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000002A3E6A39D90>
parameters = [('471f8a0dad00409db7d317c7738a194e', '9dd9b36de50c4aab88a4ca0f4caa3b62', None, None, '2023-10-01', 'Manual Payment', ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E57C3740>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('471f8a0dad00409db7d317c7738a194e', '9dd9b36de50c4aab88a4ca0f4caa3b62', None, None, '2023-10-01', 'Manual Payment', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5991FD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: payments.merchant_id

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002A3E590F570>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...8588')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] User object at 0x2a3e590e7a0>
sample_category = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] Category object at 0x2a3e590de10>

    def test_get_payment_by_id(db_session, test_user, sample_category):
        # Create manually
        payment = Payment(
            user_id=test_user.id,
            category_id=sample_category.id,
            title="Manual Payment",
            date=date(2023, 10, 1),
            amount=Decimal("-10.00"),
            bank_id=None,
        )
        db_session.add(payment)
>       db_session.commit()

tests\payments\test_service.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E57C3740>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('471f8a0dad00409db7d317c7738a194e', '9dd9b36de50c4aab88a4ca0f4caa3b62', None, None, '2023-10-01', 'Manual Payment', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5991FD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
E       [SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('471f8a0dad00409db7d317c7738a194e', '9dd9b36de50c4aab88a4ca0f4caa3b62', None, None, '2023-10-01', 'Manual Payment', None, -10.0, 'pix', 'bdd7eceeac664ccd9d02e8a90d42baee', '2026-01-16 18:54:31.818582', '2026-01-16 18:54:31.818588')]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError
_________________________ test_get_payment_not_found __________________________

db_session = <sqlalchemy.orm.session.Session object at 0x000002A3E576D7B0>
test_user = <User(username='test@example.com', first_name='Test', last_name='User')>

    def test_get_payment_not_found(db_session, test_user):
        with pytest.raises(PaymentNotFoundError):
>           service.get_payment_by_id(test_user, db_session, uuid4())

tests\payments\test_service.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

current_user = <User(username='test@example.com', first_name='Test', last_name='User')>
db = <sqlalchemy.orm.session.Session object at 0x000002A3E576D7B0>
payment_id = UUID('6612dbf6-fe93-424c-86d6-c97c84f5b285')

    def get_payment_by_id(
        current_user: TokenData, db: Session, payment_id: UUID
    ) -> Payment:
        payment = (
            db.query(Payment)
            .filter(Payment.id == payment_id)
>           .filter(Payment.user_id == current_user.get_uuid())
                                       ^^^^^^^^^^^^^^^^^^^^^
            .first()
        )
E       AttributeError: 'User' object has no attribute 'get_uuid'

src\payments\service.py:370: AttributeError
_____________________________ test_pdate_payment ______________________________

self = <sqlalchemy.engine.base.Connection object at 0x000002A3E5993650>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5993D10>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000002A3E6A39D90>
parameters = [('fbbe1c0657a64a26ad67e6b51557d0e6', '8d5c7450d59347afb616fd415c111656', None, None, '2023-10-01', 'Old Title', ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E7787A40>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('fbbe1c0657a64a26ad67e6b51557d0e6', '8d5c7450d59347afb616fd415c111656', None, None, '2023-10-01', 'Old Title', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5993D10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: payments.merchant_id

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002A3E5920E50>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...6989')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] User object at 0x2a3e590fce0>
sample_category = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] Category object at 0x2a3e590f460>

    def test_pdate_payment(db_session, test_user, sample_category):
        payment = Payment(
            user_id=test_user.id,
            category_id=sample_category.id,
            title="Old Title",
            date=date(2023, 10, 1),
            amount=Decimal("-10.00"),
        )
        db_session.add(payment)
>       db_session.commit()

tests\payments\test_service.py:83: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E7787A40>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('fbbe1c0657a64a26ad67e6b51557d0e6', '8d5c7450d59347afb616fd415c111656', None, None, '2023-10-01', 'Old Title', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5993D10>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
E       [SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('fbbe1c0657a64a26ad67e6b51557d0e6', '8d5c7450d59347afb616fd415c111656', None, None, '2023-10-01', 'Old Title', None, -10.0, 'pix', 'fad4485709184100bbf9c50ec0b635f5', '2026-01-16 18:54:32.856987', '2026-01-16 18:54:32.856989')]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError
_____________________________ test_delete_payment _____________________________

self = <sqlalchemy.engine.base.Connection object at 0x000002A3E5993C50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E57BBDD0>
statement = <sqlalchemy.dialects.sqlite.base.SQLiteCompiler object at 0x000002A3E6A39D90>
parameters = [('ab9d2f281c6a4db0bb5151aab3f4d4d9', 'f854d4456fdd45489ceb1cdd04dd4795', None, None, '2023-10-01', 'To Delete', ...)]

    def _exec_single_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
        statement: Union[str, Compiled],
        parameters: Optional[_AnyMultiExecuteParams],
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for a single DBAPI
        cursor.execute() or cursor.executemany() call.
    
        """
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
    
            if generic_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor, generic_setinputsizes, context
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e, str(statement), parameters, None, context
                    )
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters: Optional[_AnyExecuteParams]
    
        if not context.executemany:
            effective_parameters = parameters[0]
        else:
            effective_parameters = parameters
    
        if self._has_events or self.engine._has_events:
            for fn in self.dispatch.before_cursor_execute:
                str_statement, effective_parameters = fn(
                    self,
                    cursor,
                    str_statement,
                    effective_parameters,
                    context,
                    context.executemany,
                )
    
        if self._echo:
            self._log_info(str_statement)
    
            stats = context._get_cache_stats()
    
            if not self.engine.hide_parameters:
                self._log_info(
                    "[%s] %r",
                    stats,
                    sql_util._repr_params(
                        effective_parameters,
                        batches=10,
                        ismulti=context.executemany,
                    ),
                )
            else:
                self._log_info(
                    "[%s] [SQL parameters hidden due to hide_parameters=True]",
                    stats,
                )
    
        evt_handled: bool = False
        try:
            if context.execute_style is ExecuteStyle.EXECUTEMANY:
                effective_parameters = cast(
                    "_CoreMultiExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_executemany:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_executemany(
                        cursor,
                        str_statement,
                        effective_parameters,
                        context,
                    )
            elif not effective_parameters and context.no_parameters:
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute_no_params:
                        if fn(cursor, str_statement, context):
                            evt_handled = True
                            break
                if not evt_handled:
                    self.dialect.do_execute_no_params(
                        cursor, str_statement, context
                    )
            else:
                effective_parameters = cast(
                    "_CoreSingleExecuteParams", effective_parameters
                )
                if self.dialect._has_events:
                    for fn in self.dialect.dispatch.do_execute:
                        if fn(
                            cursor,
                            str_statement,
                            effective_parameters,
                            context,
                        ):
                            evt_handled = True
                            break
                if not evt_handled:
>                   self.dialect.do_execute(
                        cursor, str_statement, effective_parameters, context
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E72AF940>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('ab9d2f281c6a4db0bb5151aab3f4d4d9', 'f854d4456fdd45489ceb1cdd04dd4795', None, None, '2023-10-01', 'To Delete', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E57BBDD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: payments.merchant_id

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002A3E5968A50>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...4139')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] User object at 0x2a3e576dd00>
sample_category = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] Category object at 0x2a3e6a19e50>

    def test_delete_payment(db_session, test_user, sample_category):
        payment = Payment(
            user_id=test_user.id,
            category_id=sample_category.id,
            title="To Delete",
            date=date(2023, 10, 1),
            amount=Decimal("-10.00"),
        )
        db_session.add(payment)
>       db_session.commit()

tests\payments\test_service.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1233: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1846: in _execute_context
    return self._exec_single_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1986: in _exec_single_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1967: in _exec_single_context
    self.dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E72AF940>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('ab9d2f281c6a4db0bb5151aab3f4d4d9', 'f854d4456fdd45489ceb1cdd04dd4795', None, None, '2023-10-01', 'To Delete', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E57BBDD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
E       [SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('ab9d2f281c6a4db0bb5151aab3f4d4d9', 'f854d4456fdd45489ceb1cdd04dd4795', None, None, '2023-10-01', 'To Delete', None, -10.0, 'pix', 'aa0f91b329cf42d4807eb2f8ec136ab9', '2026-01-16 18:54:33.544137', '2026-01-16 18:54:33.544139')]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError
____________________________ test_search_payments _____________________________

self = <sqlalchemy.engine.base.Connection object at 0x000002A3E59934D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5992F90>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if engine_events:
            _WORKAROUND_ISSUE_13018 = getattr(
                self, "_WORKAROUND_ISSUE_13018", False
            )
        else:
            _WORKAROUND_ISSUE_13018 = False
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

.venv\Lib\site-packages\sqlalchemy\engine\base.py:2125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E6A265C0>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_i...ALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('946fbf5c6e164fadadc50bf69b15ed44', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-01', 'Alpha', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5992F90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: NOT NULL constraint failed: payments.merchant_id

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002A3E595D4F0>
test_user = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...2954')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] User object at 0x2a3e590f570>
sample_category = <[PendingRollbackError("This Session's transaction has been rolled back due to a previous exception during flush. To b...')]\n(Background on this error at: https://sqlalche.me/e/20/gkpj)") raised in repr()] Category object at 0x2a3e6a19c50>

    def test_search_payments(db_session, test_user, sample_category):
        # Create 3 payments
        p1 = Payment(
            user_id=test_user.id,
            category_id=sample_category.id,
            title="Alpha",
            date=date(2023, 10, 1),
            amount=Decimal("-10"),
        )
        p2 = Payment(
            user_id=test_user.id,
            category_id=sample_category.id,
            title="Beta",
            date=date(2023, 10, 2),
            amount=Decimal("-20"),
        )
        p3 = Payment(
            user_id=test_user.id,
            category_id=sample_category.id,
            title="Gamma",
            date=date(2023, 10, 3),
            amount=Decimal("-30"),
        )
    
        db_session.add_all([p1, p2, p3])
>       db_session.commit()

tests\payments\test_service.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
.venv\Lib\site-packages\sqlalchemy\orm\session.py:2030: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1311: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
.venv\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\orm\session.py:1286: in _prepare_impl
    self.session.flush()
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4331: in flush
    self._flush(objects)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4466: in _flush
    with util.safe_reraise():
         ^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
.venv\Lib\site-packages\sqlalchemy\orm\session.py:4427: in _flush
    flush_context.execute()
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
.venv\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
.venv\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
.venv\Lib\site-packages\sqlalchemy\sql\elements.py:527: in _execute_on_connection
    return connection._execute_clauseelement(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2133: in _exec_insertmany_context
    self._handle_dbapi_exception(
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2363: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
.venv\Lib\site-packages\sqlalchemy\engine\base.py:2125: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002A3E4FA8980>
cursor = <sqlite3.Cursor object at 0x000002A3E6A265C0>
statement = 'INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_i...ALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)'
parameters = ('946fbf5c6e164fadadc50bf69b15ed44', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-01', 'Alpha', ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002A3E5992F90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
E       [SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
E       [parameters: ('946fbf5c6e164fadadc50bf69b15ed44', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-01', 'Alpha', None, -10.0, 'pix', 'd18da55cba7840a8adc9fa61cad77c25', '2026-01-16 18:54:34.152941', '2026-01-16 18:54:34.152946', 'a096a9474bc2476099074a332630605b', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-02', 'Beta', None, -20.0, 'pix', 'd18da55cba7840a8adc9fa61cad77c25', '2026-01-16 18:54:34.152951', '2026-01-16 18:54:34.152951', 'd6ffaf98da704a03a1821740753ac4a9', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-03', 'Gamma', None, -30.0, 'pix', 'd18da55cba7840a8adc9fa61cad77c25', '2026-01-16 18:54:34.152954', '2026-01-16 18:54:34.152954')]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

.venv\Lib\site-packages\sqlalchemy\engine\default.py:952: IntegrityError
=========================== short test summary info ===========================
FAILED tests/payments/test_controller.py::test_create_payment_api - AssertionError: assert '-50.5000000000' == -50.5
FAILED tests/payments/test_parsers.py::test_parse_invoice_valid_csv - AssertionError: assert PaymentMethodSchema(value='credit_card', display_name='Cart\xe3o de Cr\xe9dito') == <PaymentMethod.CreditCard: 'credit_card'>
 +  where PaymentMethodSchema(value='credit_card', display_name='Cart\xe3o de Cr\xe9dito') = PaymentImportResponse(id=None, date=datetime.date(2023, 10, 1), title='Lunch', amount=Decimal('-25.50'), category=None, has_merchant=True, already_exists=False, payment_method=PaymentMethodSchema(value='credit_card', display_name='Cart\xe3o de Cr\xe9dito')).payment_method
 +  and   <PaymentMethod.CreditCard: 'credit_card'> = PaymentMethod.CreditCard
FAILED tests/payments/test_parsers.py::test_parse_statement_valid_csv - AssertionError: assert PaymentMethodSchema(value='pix', display_name='Pix') == <PaymentMethod.Pix: 'pix'>
 +  where PaymentMethodSchema(value='pix', display_name='Pix') = PaymentImportResponse(id=None, date=datetime.date(2023, 10, 1), title='Jo\xe3o Silva', amount=Decimal('-50.00'), category=None, has_merchant=True, already_exists=False, payment_method=PaymentMethodSchema(value='pix', display_name='Pix')).payment_method
 +  and   <PaymentMethod.Pix: 'pix'> = PaymentMethod.Pix
FAILED tests/payments/test_service.py::test_create_payment - AttributeError: 'User' object has no attribute 'get_uuid'
FAILED tests/payments/test_service.py::test_get_payment_by_id - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
[SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
[parameters: ('471f8a0dad00409db7d317c7738a194e', '9dd9b36de50c4aab88a4ca0f4caa3b62', None, None, '2023-10-01', 'Manual Payment', None, -10.0, 'pix', 'bdd7eceeac664ccd9d02e8a90d42baee', '2026-01-16 18:54:31.818582', '2026-01-16 18:54:31.818588')]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
FAILED tests/payments/test_service.py::test_get_payment_not_found - AttributeError: 'User' object has no attribute 'get_uuid'
FAILED tests/payments/test_service.py::test_pdate_payment - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
[SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
[parameters: ('fbbe1c0657a64a26ad67e6b51557d0e6', '8d5c7450d59347afb616fd415c111656', None, None, '2023-10-01', 'Old Title', None, -10.0, 'pix', 'fad4485709184100bbf9c50ec0b635f5', '2026-01-16 18:54:32.856987', '2026-01-16 18:54:32.856989')]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
FAILED tests/payments/test_service.py::test_delete_payment - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
[SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
[parameters: ('ab9d2f281c6a4db0bb5151aab3f4d4d9', 'f854d4456fdd45489ceb1cdd04dd4795', None, None, '2023-10-01', 'To Delete', None, -10.0, 'pix', 'aa0f91b329cf42d4807eb2f8ec136ab9', '2026-01-16 18:54:33.544137', '2026-01-16 18:54:33.544139')]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
FAILED tests/payments/test_service.py::test_search_payments - sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) NOT NULL constraint failed: payments.merchant_id
[SQL: INSERT INTO payments (id, user_id, merchant_id, bank_id, date, title, description, amount, payment_method, category_id, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?), (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)]
[parameters: ('946fbf5c6e164fadadc50bf69b15ed44', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-01', 'Alpha', None, -10.0, 'pix', 'd18da55cba7840a8adc9fa61cad77c25', '2026-01-16 18:54:34.152941', '2026-01-16 18:54:34.152946', 'a096a9474bc2476099074a332630605b', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-02', 'Beta', None, -20.0, 'pix', 'd18da55cba7840a8adc9fa61cad77c25', '2026-01-16 18:54:34.152951', '2026-01-16 18:54:34.152951', 'd6ffaf98da704a03a1821740753ac4a9', '62a46ec322e949119ad309e6fad9c24d', None, None, '2023-10-03', 'Gamma', None, -30.0, 'pix', 'd18da55cba7840a8adc9fa61cad77c25', '2026-01-16 18:54:34.152954', '2026-01-16 18:54:34.152954')]
(Background on this error at: https://sqlalche.me/e/20/gkpj)
========================= 9 failed, 4 passed in 5.10s =========================
